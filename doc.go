package main

// TODO
//  что надо  67.0 и  67.255 из стиринги в  инты сравить и обратно в строку  bytes.Buffer

// 21.10 14:11 стоял на смене и пришла мысль в голову , что последнее число  всегда будет в диапапозоне
//  от 0 до 255 (67.0). нужно просто создать Enum от 0 до 255 и подставить в цикле в строку  bytes.Buffer

// 22.10 3:06  81 это (56 49) а 82 это (56 50). 112 (49 49 50) - 123(49 50 51).
//  циферки в таблице ascii от 0 до 9  в таблице ascii  от 48  до 57
//  ТО ЕСТЬ  увеличиваем крайний байт до  0 (112 - 119  потом  сбрасываем на 0(48) 110) с увеличением предыдущего
// байта на +1 (110 [49 49 48] до 120 [49 50 48])

// 24.10 1:33 stringPointIndexes возвращает локальный массив с индексами всех точек в строке и в removesPointAndDash
// собираю строку в bytes.Buffer

// 28.10 12:10  написать функцию сustomStringBilder , которая будет собирать строку чанками по индексам в bytes.Buffer.
// посмотреть что проще( выделени памяти ,меньше писать кода) брать кусочек(ранджом индексов) строки и конвертить в int
//  и инкреметить...... или же откручивать ноль форам до 255 ,а цифру перед увеличивать на байт(смотри строку №9)

//   "под чем" я писал буквы 28.10 )))))

// 30.10 00:07
/*
	и так ..... чанки.

	 есть idxSymbols(idxSymbols = []int{1, 3, 6, 8, 10, 12, 16}) строка 5.1.10.0-5.1.100.255
	 в idxSymbols лежат индексы всех точек и тире в строке

	 чтобы получить строку с число допустим  "10". нужно взять строку

	 str := "5.11.10.0-5.11.20.255" и вот так

	str[:1] = 5 str[:idx[0]]
	str[2:3] = 11 str[idx[0]+1:idx[1]]
	str[4:6] = 10 str[idx[1]+1:idx[2]]
	str[7:8] = 0 str[idx[2]+1:idx[3]]

	последние 2 значения "20" и "255"

	str[idx[5]+1:idx[6]]
	str[idx[6]+1:]

	значение  idxSymbols +1 : до следующей точки(индекса)

	4-тый  индекс idxSymbols  тире

	вот это все тестанул ручка(пока не понимаю как писат тесты правильно ) на 3-х строках

	5.100.67.0-5.100.67.255 [1 5 8 10 12 16 19]
	5.1.10.0-5.1.100.255  	[1 3 6 8 10 12 16]
	5.11.10.0-5.11.20.255 	[1 4 7 9 11 14 17]

*/
